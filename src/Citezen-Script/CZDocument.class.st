"
A CZDocument represents a document. It takes all the elements, an outputer, and creates the final file on the hard drive.
N.B.: Some options will obviously ignored, for example orderedList & unorderedList, when you don't export with the good outputer (here the BibTeX outputer ignore these two options).

Example: 

CZDocument new
	addElement: (CZCommentElement new comment: 'Generated by Citezen -- http://www.pharo-project.org');
	addElement: (CZTitleElement new title: 'Bibliography : '; htmlLevel: 2);
	addElement: (CZTitleElement new title: 'Script 1'; htmlLevel: 3);
	addElement: script1;
	addElement: (CZTitleElement new title: 'Script 2'; htmlLevel: 3);
	addElement: script2;
	exportAsHtml;
	inputFile: '/Users/.../myReferences.bib';
	outputFile: '/Users/.../myWebPage.html';
	generate
	
Some details about theses messages: (all messages are in the interface protocol)
- addElement: aDocumentElement -> adds an element to the document (CZCommentElement, CZTitleElement, CZScript). The elements will be displayed in the order they were added.
- doNotRestartOrderedListAtEachScript & restartOrderedListAtEachScript -> In xHTML, corresponds to specifie the ""start"" parameter to 1 or to last index of previous script + 1 (default is restartOrderedListAtEachScript).
- exportAsText, exportAsBib & exportAsHtml -> choose the export format (default is exportAsHtml)
- footer: aString & header: aString -> specifies a header or a footer (ignored by all outputers except xHTML)
- inputFile: aString & outputFile: aString -> specifies the paths of input and output files; if no outputFile is given, the generation will only be stored as a string returned by generate and getLastOutput
- orderedList & unorderedList -> choice between <ol> and <ul>
- withHeaderAndFooter & withoutHeaderAndFooter -> if you want to generate some xHTML code and include it in another web page, send withoutHeaderAndFooter (default is withHeaderAndFooter)
- withDoubles & withoutDoubles -> if you want that the scripts include entries allready displayed, use withDoubles (default is  withoutDoubles)
- getLastOutput -> returns a String containing the last output
- generate -> generates the document, shoud be the LAST message you send ; it returns a string containing the document too


If you just want to take your file and transform it in another format, without any query, you can just write that:
CZDocument new
inputFile: '/Users/.../myReferences.bib';
outputFile: '/Users/.../myWebPage.html';
generate
It will generate a xHTML document with all your BibTeX file.
"
Class {
	#name : #CZDocument,
	#superclass : #Object,
	#instVars : [
		'originalBibset',
		'outputFile',
		'outputer',
		'elements',
		'entriesDisplayed',
		'listIndex',
		'restartOrdered',
		'withoutHeaderAndFooter',
		'header',
		'footer',
		'changed',
		'authorDisplay',
		'inputFile',
		'lastBibsetRequested',
		'withoutDoubles',
		'entriesAlleadyDisplayed'
	],
	#classInstVars : [
		'exportTypeMatching'
	],
	#category : #'Citezen-Script'
}

{ #category : #types }
CZDocument class >> bibExporterEncoding [
	^ #bib
]

{ #category : #'as yet unclassified' }
CZDocument class >> defaultExportType [ 
	^ self htmlExporterEncoding 
]

{ #category : #'as yet unclassified' }
CZDocument class >> defaultOutputer [ 
	^ self matchType: self defaultExportType 
]

{ #category : #'as yet unclassified' }
CZDocument class >> htmlExporterEncoding [
	^ #html
]

{ #category : #'as yet unclassified' }
CZDocument class >> initializeExportTypeMatching [
	
	exportTypeMatching := Dictionary new.
	CZOutputer allSubclassesDo: [:each |
			exportTypeMatching at: each exporterEncoding put: each
			]
	
	 
		
]

{ #category : #'as yet unclassified' }
CZDocument class >> matchType: aString [
	exportTypeMatching ifNil: [ self initializeExportTypeMatching ].
	^ exportTypeMatching at: aString ifAbsent: [self defaultExportType]
]

{ #category : #'as yet unclassified' }
CZDocument class >> textExporterEncoding [
	^ #text
]

{ #category : #'as yet unclassified' }
CZDocument >> acceptVisitor: aVisitor [
	aVisitor visitDocument: self
]

{ #category : #interface }
CZDocument >> addElement: aDocumentElement [
	(aDocumentElement isNil | elements includes: aDocumentElement)
		ifFalse: [
			changed 
			ifTrue: [ elements add: aDocumentElement ]
			ifFalse: [ elements add: aDocumentElement beforeIndex: elements size ].
			
			(aDocumentElement class = CZScript) 
				ifTrue: [ 
					aDocumentElement document: self.
					(changed) ifFalse: [ changed := true. elements removeLast ] 
				] 
		]
]

{ #category : #'as yet unclassified' }
CZDocument >> addEntriesDisplayed: aNumber [
	restartOrdered ifFalse: [
	listIndex := listIndex + aNumber ]
]

{ #category : #'as yet unclassified' }
CZDocument >> bibsetInput: aCZSet [
	originalBibset := aCZSet.
	aCZSet scope: CZSet standardDefinitions 
]

{ #category : #'as yet unclassified' }
CZDocument >> createBibSetFromPath [
	originalBibset := CZBibParser parse: ((FileStream readOnlyFileNamed: inputFile) contents).
	originalBibset scope: CZSet standardDefinitions 
]

{ #category : #interface }
CZDocument >> displayFullName [
	authorDisplay := CZPeople displayFullName
]

{ #category : #interface }
CZDocument >> displayNormalizedName [
	authorDisplay := CZPeople displayNormalizedName
]

{ #category : #interface }
CZDocument >> displayShortenedName [
	authorDisplay := CZPeople displayShortenedName
]

{ #category : #interface }
CZDocument >> doNotRestartOrderedListAtEachScript [
	restartOrdered := false
]

{ #category : #'as yet unclassified' }
CZDocument >> elements [
	^ elements
]

{ #category : #interface }
CZDocument >> exportAsBib [
	self exportType: CZBibtexOutputer exporterEncoding
]

{ #category : #interface }
CZDocument >> exportAsHtml [
	self exportType: CZHtmlOutputer exporterEncoding
]

{ #category : #interface }
CZDocument >> exportAsText [

	self exportType: CZTextOutputer exporterEncoding
]

{ #category : #'as yet unclassified' }
CZDocument >> exportType: aString [
	outputer := (self class matchType: aString) new
]

{ #category : #'as yet unclassified' }
CZDocument >> footer [
	^ footer
]

{ #category : #interface }
CZDocument >> footer: aString [
	footer := aString 
]

{ #category : #interface }
CZDocument >> generate [
	inputFile ifNotNilDo: [ :e | self createBibSetFromPath ].
	entriesAlleadyDisplayed := OrderedCollection new.
	
	outputer ifNil: [ outputer := self class defaultOutputer new ].
	outputer setOutputFile: outputFile.
	outputer setAuthorDisplayOption: authorDisplay.
	
	outputer getOutputFor: self.
	(outputFile isNil)
		ifFalse: [ Transcript cr; show: '(Citezen >) ', outputFile, ' was successfully generated' ]
		ifTrue: [ Transcript cr; show: '(Citezen >) end of generation' ].
	^ self getLastOutput
	
	

]

{ #category : #interface }
CZDocument >> getLastOutput [
	^ outputer getLastOutput
]

{ #category : #'as yet unclassified' }
CZDocument >> getWithoutHeaderAndFooter [
	^ withoutHeaderAndFooter 
]

{ #category : #'as yet unclassified' }
CZDocument >> header [ 
	^ header 
]

{ #category : #interface }
CZDocument >> header: aString [
	header := aString 
]

{ #category : #'as yet unclassified' }
CZDocument >> initialize [ 
	super initialize.
	
	changed := false.
	elements := OrderedCollection with: (CZScript new document: self).
	self withDoubles.
	self displayFullName.
	self withHeaderAndFooter.
	self unorderedList.
	self restartOrderedListAtEachScript
]

{ #category : #interface }
CZDocument >> inputFile: aString [
	inputFile := aString
]

{ #category : #'as yet unclassified' }
CZDocument >> listIndex [
	^ listIndex
]

{ #category : #interface }
CZDocument >> orderedList [
	listIndex := 1.
	restartOrdered := true
]

{ #category : #'as yet unclassified' }
CZDocument >> originalBibset [
	^ originalBibset 
]

{ #category : #interface }
CZDocument >> outputFile: aString [
	outputFile := aString
]

{ #category : #'as yet unclassified' }
CZDocument >> requestBibset [
	| newBibSet |

	withoutDoubles ifFalse: [ ^ lastBibsetRequested := originalBibset copyTwoLevel ].
	lastBibsetRequested ifNil: [ ^ lastBibsetRequested := originalBibset copyTwoLevel ].
	
	newBibSet := CZSet withStandardDefinitions.
	
	entriesAlleadyDisplayed addAll: lastBibsetRequested entries.
	(originalBibset entries reject: [ :each | entriesAlleadyDisplayed includes: each]) do: [ :each | newBibSet addEntry: each].
	originalBibset macros do: [ :each | newBibSet addMacro: each].
	
	^ lastBibsetRequested := newBibSet
]

{ #category : #interface }
CZDocument >> restartOrderedListAtEachScript [
	restartOrdered := true
]

{ #category : #interface }
CZDocument >> unorderedList [
	listIndex := 0
]

{ #category : #interface }
CZDocument >> withDoubles [
	withoutDoubles := false
]

{ #category : #interface }
CZDocument >> withHeaderAndFooter [
	withoutHeaderAndFooter := false
]

{ #category : #interface }
CZDocument >> withoutDoubles [
	withoutDoubles := true
]

{ #category : #interface }
CZDocument >> withoutHeaderAndFooter [
	withoutHeaderAndFooter := true
]
