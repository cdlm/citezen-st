"
A document represents a structured/generated list of entries potentially annotated with title or comments.
A document can be generated from scripts that composed it.

This document will keep all the options for your final document (export format, output path, ...).
Then you should add all the elements to the document, in the order you want to display them. There are three kind of elements: CZTitleElement, CZCommentElement, and CZScript. Of course, new elements can be created if you need it.

A CZscript will then be associated with an bibset from which CZEntries are queried and added to the CZDocument. Finally, a CZDocument is associated with an outputter that will generate the document in the corresponding format. 

Note that there is a lot of messages for the html export format. They are stored in the html-interface protocol.

-----

A CZDocument represents a document. It takes all the elements, an outputer, and creates the final file on the hard drive.
N.B.: Some options will obviously ignored, for example orderedList & unorderedList, when you don't export with the good outputer (here the BibTeX outputer ignore these two options).

Example: 

CZDocument new
	addElement: (CZCommentElement new comment: 'Generated by Citezen -- http://www.pharo-project.org');
	addElement: (CZTitleElement new title: 'Bibliography : '; htmlLevel: 2);
	addElement: (CZTitleElement new title: 'Script 1'; htmlLevel: 3);
	addElement: script1;
	addElement: (CZTitleElement new title: 'Script 2'; htmlLevel: 3);
	addElement: script2;
	exportAsHtml;
	inputFile: '/Users/.../myReferences.bib';
	outputFile: '/Users/.../myWebPage.html';
	generate
	
Some details about theses messages: (all messages are in the interface and html-interface protocols)
- addElement: aDocumentElement -> adds an element to the document (CZCommentElement, CZTitleElement, CZScript). The elements will be displayed in the order they were added.
- doNotRestartOrderedListAtEachScript & restartOrderedListAtEachScript -> In xHTML, corresponds to specifie the ""start"" parameter to 1 or to last index of previous script + 1 (default is restartOrderedListAtEachScript).
- exportAsText, exportAsBib & exportAsHtml ->  selects the export format (default is exportAsHtml)
- footer: aString & header: aString -> specifies a header or a footer (ignored by all outputers except xHTML)
- inputFile: aString & outputFile: aString -> specifies the paths of input and output files; if no outputFile is given, the generation will only be stored as a string returned by generate and getLastOutput
- orderedList & unorderedList -> choice between <ol> and <ul>
- withHeaderAndFooter & withoutHeaderAndFooter -> if you want to generate some xHTML code and include it in another web page, send withoutHeaderAndFooter (default is withHeaderAndFooter)
- withDoubles & withoutDoubles -> if you want that the scripts include entries allready displayed, use withDoubles (default is  withoutDoubles)
- getLastOutput -> returns a String containing the last output
- generate -> generates the document, shoud be the LAST message you send ; it returns a string containing the document too


When you create a document, it creates a fake script and add it to the element, that will be deleted when you add one of your scripts.
As a consequence, if you just want to take your file and transform it in another format without any query, note you can just write that:
CZDocument new
	inputFile: '/Users/.../myReferences.bib';
	outputFile: '/Users/.../myWebPage.html';
	generate
It will generate a xHTML document with all your BibTeX file.


"
Class {
	#name : #CZDocument,
	#superclass : #Object,
	#instVars : [
		'originalBibset',
		'outputFile',
		'outputer',
		'elements',
		'entriesDisplayed',
		'listIndex',
		'restartOrdered',
		'withoutHeaderAndFooter',
		'header',
		'footer',
		'changed',
		'authorDisplay',
		'inputFile',
		'lastBibsetRequested',
		'withoutDoubles',
		'entriesAlreadyDisplayed'
	],
	#classInstVars : [
		'exportTypeMatching'
	],
	#category : #'Citezen-Script'
}

{ #category : #types }
CZDocument class >> bibExporterEncoding [
	^ #bib
]

{ #category : #default }
CZDocument class >> defaultExportType [ 
	^ self htmlExporterEncoding 
]

{ #category : #default }
CZDocument class >> defaultOutputer [ 
	^ self matchType: self defaultExportType 
]

{ #category : #'as yet unclassified' }
CZDocument class >> htmlExporterEncoding [
	^ #html
]

{ #category : #'as yet unclassified' }
CZDocument class >> initializeExportTypeMatching [
	"self initializeExportTypeMatching"
	
	exportTypeMatching := Dictionary new.
	CZOutputer allSubclassesDo: [:each |
			exportTypeMatching at: each exporterEncoding put: each
			]
	
	 
		
]

{ #category : #'as yet unclassified' }
CZDocument class >> matchType: aString [
	exportTypeMatching ifNil: [ self initializeExportTypeMatching ].
	^ exportTypeMatching at: aString ifAbsent: [self defaultExportType]
]

{ #category : #'as yet unclassified' }
CZDocument class >> textExporterEncoding [
	^ #text
]

{ #category : #visiting }
CZDocument >> acceptVisitor: aVisitor [
	aVisitor visitDocument: self
]

{ #category : #'public interface' }
CZDocument >> addElement: aDocumentElement [
	(aDocumentElement isNil | elements includes: aDocumentElement)
		ifFalse: [
			changed 
			ifTrue: [ elements add: aDocumentElement ]
			ifFalse: [ elements add: aDocumentElement beforeIndex: elements size ].
			
			(aDocumentElement class = CZScript) 
				ifTrue: [ 
					aDocumentElement document: self.
					(changed) ifFalse: [ changed := true. elements removeLast ] 
				] 
		]
]

{ #category : #'as yet unclassified' }
CZDocument >> bibsetInput: aCZSet [
	originalBibset := aCZSet.
	aCZSet scope: CZSet standardDefinitions 
]

{ #category : #'as yet unclassified' }
CZDocument >> createBibSetFromPath [
	
	originalBibset := CZBibParser parse: ((FileStream readOnlyFileNamed: inputFile) contents).
	originalBibset scope: CZSet standardDefinitions 
]

{ #category : #'public interface' }
CZDocument >> displayFullName [
	authorDisplay := CZPeople displayFullName
]

{ #category : #'public interface' }
CZDocument >> displayNormalizedName [
	authorDisplay := CZPeople displayNormalizedName
]

{ #category : #'public interface' }
CZDocument >> displayShortenedName [
	authorDisplay := CZPeople displayShortenedName
]

{ #category : #'output template' }
CZDocument >> doNotRestartOrderedListAtEachScript [
	restartOrdered := false
]

{ #category : #accessing }
CZDocument >> elements [
	"elements contains comment, script..."
	^ elements
]

{ #category : #accessing }
CZDocument >> entitiesAlreadyTreated [
	"Return the list of entities that have been already considered by probably an exporter."
	^ entriesAlreadyDisplayed
]

{ #category : #export }
CZDocument >> exportAsBib [
	self exporterType: CZBibtexOutputer exporterEncoding
]

{ #category : #export }
CZDocument >> exportAsHtml [
	self exporterType: CZHtmlOutputer exporterEncoding
]

{ #category : #export }
CZDocument >> exportAsLaTeX [
	self exporterType: CZLaTeXOutputer exporterEncoding
]

{ #category : #export }
CZDocument >> exportAsText [
	self exporterType: CZTextOutputer exporterEncoding
]

{ #category : #'as yet unclassified' }
CZDocument >> exporterType: aSymbol [
	"set the exporter corresponding to the specified type represented by aSymbol. 
	aSymbol should be one of the value returned by the class method exporterEncoding"
	
	outputer := (self class matchType: aSymbol) new
]

{ #category : #'public interface' }
CZDocument >> fillUpOriginalSet [
	inputFile ifNotNil: [ self createBibSetFromPath ].
	
	

]

{ #category : #'output template' }
CZDocument >> footer [
	^ footer
]

{ #category : #'output template' }
CZDocument >> footer: aString [
	footer := aString 
]

{ #category : #'public interface' }
CZDocument >> generate [

	self fillUpOriginalSet.
	entriesAlreadyDisplayed := OrderedCollection new.
	
	outputer ifNil: [ outputer := self class defaultOutputer new ].
	outputer setOutputFile: outputFile.
	outputer setAuthorDisplayOption: authorDisplay.
	
	outputer getOutputFor: self.
	outputFile isNil
		ifFalse: [ Transcript cr; show: '(Citezen >) ', outputFile, ' was successfully generated' ]
		ifTrue: [ Transcript cr; show: '(Citezen >) end of generation' ].
	^ self getLastOutput
	
	

]

{ #category : #'public interface' }
CZDocument >> getLastOutput [
	^ outputer getLastOutput
]

{ #category : #'output template' }
CZDocument >> getWithoutHeaderAndFooter [
	^ withoutHeaderAndFooter 
]

{ #category : #'output template' }
CZDocument >> header [ 
	^ header 
]

{ #category : #'output template' }
CZDocument >> header: aString [
	header := aString 
]

{ #category : #initialize }
CZDocument >> initialize [ 

	super initialize.
	changed := false.
	elements := OrderedCollection with: (CZScript new document: self).
	self withDoubles.
	self displayFullName.
	self withHeaderAndFooter.
	self unorderedList.
	self restartOrderedListAtEachScript
]

{ #category : #'in out' }
CZDocument >> inputFile: aString [
	inputFile := aString
]

{ #category : #accessing }
CZDocument >> listIndex [
	^ listIndex
]

{ #category : #'output template' }
CZDocument >> orderedList [
	listIndex := 1.
	restartOrdered := true
]

{ #category : #accessing }
CZDocument >> originalBibset [
	"the originalBibSet is the source of bibentries from which a document is built based on scripts"
	^ originalBibset 
]

{ #category : #'in out' }
CZDocument >> outputFile: aString [
	outputFile := aString
]

{ #category : #'as yet unclassified' }
CZDocument >> requestBibset [
	"this method looks difficult to understand to me. Should change it"

	| newBibSet |
	withoutDoubles ifFalse: [ ^ lastBibsetRequested := originalBibset copyTwoLevel ].
	lastBibsetRequested ifNil: [ ^ lastBibsetRequested := originalBibset copyTwoLevel ].
	
	newBibSet := CZSet withStandardDefinitions.
	
	entriesAlreadyDisplayed addAll: lastBibsetRequested entries.
	(originalBibset entries reject: [ :each | entriesAlreadyDisplayed includes: each]) 
		do: [ :each | newBibSet addEntry: each].
	originalBibset macros do: [ :each | newBibSet addMacro: each].
	
	^ lastBibsetRequested := newBibSet
]

{ #category : #'output template' }
CZDocument >> restartOrderedListAtEachScript [
	restartOrdered := true
]

{ #category : #'output template' }
CZDocument >> unorderedList [
	listIndex := 0
]

{ #category : #'as yet unclassified' }
CZDocument >> updateNumberOfTreatedEntries: aNumber [
	restartOrdered 
		ifFalse: [ listIndex := listIndex + aNumber ]
]

{ #category : #'public interface' }
CZDocument >> withDoubles [
	withoutDoubles := false
]

{ #category : #'output template' }
CZDocument >> withHeaderAndFooter [
	withoutHeaderAndFooter := false
]

{ #category : #'public interface' }
CZDocument >> withoutDoubles [
	withoutDoubles := true
]

{ #category : #'output template' }
CZDocument >> withoutHeaderAndFooter [
	withoutHeaderAndFooter := true
]
